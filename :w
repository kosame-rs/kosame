use std::collections::HashMap;

use syn::{
    AttrStyle, Ident, LitInt, LitStr, Path, Token, parenthesized,
    parse::{Parse, ParseStream},
    punctuated::Punctuated,
    spanned::Spanned,
};

use crate::{driver::Driver, keyword, proc_macro_error::emit_call_site_error, schema::Table};

macro_rules! define_attribute {
    (
        $(#[$meta:meta])*
        $vis:vis struct $name:ident {
            $($field:ident: $ty:ty),* $(,)?
        }
    ) => {
        $(#[$meta])*
        $vis struct $name {
            $($field: $ty),*
        }

        impl $name {
            pub fn parse_attrs(attrs: &[syn::Attribute]) -> syn::Result<Self> {
                $(
                    let $field = None;
                )*


                Ok(Self {
                    $(
                        $field: define_attribute!(@required_error $field: $ty),
                    )*
                })
            }
        }
    };

    (@required_error $field:ident: Option<$ty:ty>) => { $field };
    (@required_error $field:ident: $ty:ty) => {
        $field.ok_or_else(|| syn::Error::new(

        ))?
    };
}

define_attribute! {
    struct TableAttr {
        kek: i32,
    }
}

#[derive(Default)]
pub struct CustomMeta {
    pub driver: Option<MetaDriver>,
    pub rename: Option<MetaRename>,
    pub type_override: Option<MetaTypeOverride>,

    pub pass: Option<MetaPass>,
    pub tables: HashMap<Path, MetaTable>,
}

impl CustomMeta {
    pub fn parse_attrs(attrs: &[syn::Attribute]) -> syn::Result<Self> {
        let mut result = Self::default();

        for attr in attrs {
            if attr.path().is_ident("kosame") {
                let list = attr.meta.require_list()?;
                let items =
                    list.parse_args_with(Punctuated::<MetaItem, Token![,]>::parse_terminated)?;

                for item in items {
                    match item {
                        MetaItem::Driver(inner) => result.driver = Some(inner),
                        MetaItem::Rename(inner) => result.rename = Some(inner),
                        MetaItem::TypeOverride(inner) => result.type_override = Some(inner),
                        MetaItem::Pass(inner) => result.pass = Some(inner),
                        MetaItem::Table(inner) => {
                            result.tables.insert(inner.path.clone(), inner);
                        }
                    }
                }
            } else {
                return Err(syn::Error::new(
                    attr.span(),
                    match attr.style {
                        AttrStyle::Inner(_) => {
                            "only `#![kosame(...)]` attributes allowed in this position"
                        }
                        AttrStyle::Outer => {
                            "only `#[kosame(...)]` attributes allowed in this position"
                        }
                    },
                ));
            }
        }

        Ok(result)
    }
}

pub enum MetaItem {
    Driver(MetaDriver),
    Rename(MetaRename),
    TypeOverride(MetaTypeOverride),
    Pass(MetaPass),
    Table(MetaTable),
}

impl Parse for MetaItem {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        if input.peek(keyword::__pass) {
            return Ok(Self::Pass(input.parse()?));
        }
        if input.peek(keyword::__table) {
            return Ok(Self::Table(input.parse()?));
        }

        let lookahead = input.lookahead1();
        if lookahead.peek(keyword::driver) {
            Ok(Self::Driver(input.parse()?))
        } else if lookahead.peek(keyword::rename) {
            Ok(Self::Rename(input.parse()?))
        } else if lookahead.peek(keyword::ty) {
            Ok(Self::TypeOverride(input.parse()?))
        } else {
            keyword::group_attribute::error(input)
        }
    }
}

pub struct MetaDriver {
    pub path: keyword::driver,
    pub eq_token: Token![=],
    pub value: LitStr,
}

impl Parse for MetaDriver {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        Ok(Self {
            path: input.parse()?,
            eq_token: input.parse()?,
            value: {
                let value: LitStr = input.parse()?;
                if value.value().parse::<Driver>().is_err() {
                    return Err(syn::Error::new(value.span(), "unknown driver value"));
                }
                value
            },
        })
    }
}

pub struct MetaRename {
    pub path: keyword::rename,
    pub eq_token: Token![=],
    pub value: Ident,
}

impl Parse for MetaRename {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        Ok(Self {
            path: input.parse()?,
            eq_token: input.parse()?,
            value: input.parse()?,
        })
    }
}

pub struct MetaTypeOverride {
    pub path: keyword::ty,
    pub eq_token: Token![=],
    pub value: Path,
}

impl Parse for MetaTypeOverride {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        Ok(Self {
            path: input.parse()?,
            eq_token: input.parse()?,
            value: input.parse()?,
        })
    }
}

pub struct MetaPass {
    pub pass_keyword: keyword::__pass,
    pub eq_token: Token![=],
    pub value: LitInt,
}

impl Parse for MetaPass {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        Ok(Self {
            pass_keyword: input.parse()?,
            eq_token: input.parse()?,
            value: input.parse()?,
        })
    }
}

pub struct MetaTable {
    pub table_keyword: keyword::__table,
    pub paren_token: syn::token::Paren,
    pub path: Path,
    pub eq_token: Token![=],
    pub value: Box<Table>,
}

impl Parse for MetaTable {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let content;
        Ok(Self {
            table_keyword: input.parse()?,
            paren_token: parenthesized!(content in input),
            path: content.parse()?,
            eq_token: content.parse()?,
            value: Box::new(content.parse()?),
        })
    }
}
